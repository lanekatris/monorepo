# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

"The `@defer` directive may be provided for fragment spreads and inline fragments to inform the executor to delay the execution of the current fragment to indicate deprioritization of the current fragment. A query with `@defer` directive will cause the request to potentially return multiple responses, where non-deferred data is delivered in the initial response and data deferred is delivered in a subsequent response. `@include` and `@skip` take precedence over `@defer`."
directive @defer(
    "Deferred when true."
    if: Boolean,
    "If this argument label has a value other than null, it will be passed on to the result of this defer directive. This label is intended to give client applications a way to identify to which fragment a deferred result belongs to."
    label: String
) on FRAGMENT_SPREAD | INLINE_FRAGMENT

"The `@stream` directive may be provided for a field of `List` type so that the backend can leverage technology such as asynchronous iterators to provide a partial list in the initial response, and additional list items in subsequent responses. `@include` and `@skip` take precedence over `@stream`."
directive @stream(
    "Streamed when true."
    if: Boolean,
    "The initial elements that shall be send down to the consumer."
    initialCount: Int! = 0,
    "If this argument label has a value other than null, it will be passed on to the result of this stream directive. This label is intended to give client applications a way to identify to which fragment a streamed result belongs to."
    label: String
) on FIELD

type AttributedPlace {
    city: String
    elevation: Int
    id: Int!
    isStatePark: Int!
    name: String
    notes: String
    state: String
    tags: String
    visited: Boolean
    zip: String
}

type Bookmark {
    created: DateTime!
    id: Int!
    imageUrl: String
    meta: String
    name: String
    status: String
    tags: String
    url: String
}

"A connection to a list of items."
type BookmarkConnection {
    "A list of edges."
    edges: [BookmarkEdge!]
    "A flattened list of the nodes."
    nodes: [Bookmark!]
    "Information to aid in pagination."
    pageInfo: PageInfo!
    totalCount: Int!
}

"An edge in a connection."
type BookmarkEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Bookmark!
}

type Feed {
    created: DateTime!
    data: String
    id: Int!
    message: String
    tags: String!
    type: String!
}

type Maintenance {
    created: DateTime
    id: Int!
    name: String!
    price: Float
    property: String!
}

type Mutation {
    bookmarkCreate(tags: [String!], url: String!): Bookmark!
    bookmarkRead(id: Int!): Bookmark!
    feedItemCreate(input: FeedItemCreateInput!): Feed!
}

"Information about pagination in a connection."
type PageInfo {
    "When paginating forwards, the cursor to continue."
    endCursor: String
    "Indicates whether more edges exist following the set defined by the clients arguments."
    hasNextPage: Boolean!
    "Indicates whether more edges exist prior the set defined by the clients arguments."
    hasPreviousPage: Boolean!
    "When paginating backwards, the cursor to continue."
    startCursor: String
}

"A connection to a list of items."
type PlaceConnection {
    "A list of edges."
    edges: [PlaceEdge!]
    "A flattened list of the nodes."
    nodes: [AttributedPlace!]
    "Information to aid in pagination."
    pageInfo: PageInfo!
    totalCount: Int!
}

"An edge in a connection."
type PlaceEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: AttributedPlace!
}

type Query {
    bookmark(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        order: [BookmarkSortInput!],
        where: BookmarkFilterInput
    ): BookmarkConnection
    feed(order: [FeedSortInput!], where: FeedFilterInput): [Feed!]!
    latestHealth: [TaskDto!]!
    maintenance(order: [MaintenanceSortInput!], where: MaintenanceFilterInput): [Maintenance!]!
    place(
        "Returns the elements in the list that come after the specified cursor."
        after: String,
        "Returns the elements in the list that come before the specified cursor."
        before: String,
        "Returns the first _n_ elements from the list."
        first: Int,
        "Returns the last _n_ elements from the list."
        last: Int,
        order: [AttributedPlaceSortInput!],
        where: AttributedPlaceFilterInput
    ): PlaceConnection
    sysInfo: String!
}

type TaskDto {
    done: Boolean!
    task: String!
}

enum SortEnumType {
    ASC
    DESC
}

"The `DateTime` scalar represents an ISO-8601 compliant date time type."
scalar DateTime

input AttributedPlaceFilterInput {
    and: [AttributedPlaceFilterInput!]
    city: StringOperationFilterInput
    elevation: ComparableNullableOfInt32OperationFilterInput
    id: ComparableInt32OperationFilterInput
    isStatePark: ComparableInt32OperationFilterInput
    name: StringOperationFilterInput
    notes: StringOperationFilterInput
    or: [AttributedPlaceFilterInput!]
    state: StringOperationFilterInput
    tags: StringOperationFilterInput
    visited: BooleanOperationFilterInput
    zip: StringOperationFilterInput
}

input AttributedPlaceSortInput {
    city: SortEnumType
    elevation: SortEnumType
    id: SortEnumType
    isStatePark: SortEnumType
    name: SortEnumType
    notes: SortEnumType
    state: SortEnumType
    tags: SortEnumType
    visited: SortEnumType
    zip: SortEnumType
}

input BookmarkFilterInput {
    and: [BookmarkFilterInput!]
    created: ComparableDateTimeOperationFilterInput
    id: ComparableInt32OperationFilterInput
    imageUrl: StringOperationFilterInput
    meta: StringOperationFilterInput
    name: StringOperationFilterInput
    or: [BookmarkFilterInput!]
    status: StringOperationFilterInput
    tags: StringOperationFilterInput
    url: StringOperationFilterInput
}

input BookmarkSortInput {
    created: SortEnumType
    id: SortEnumType
    imageUrl: SortEnumType
    meta: SortEnumType
    name: SortEnumType
    status: SortEnumType
    tags: SortEnumType
    url: SortEnumType
}

input BooleanOperationFilterInput {
    eq: Boolean
    neq: Boolean
}

input ComparableDateTimeOperationFilterInput {
    eq: DateTime
    gt: DateTime
    gte: DateTime
    in: [DateTime!]
    lt: DateTime
    lte: DateTime
    neq: DateTime
    ngt: DateTime
    ngte: DateTime
    nin: [DateTime!]
    nlt: DateTime
    nlte: DateTime
}

input ComparableInt32OperationFilterInput {
    eq: Int
    gt: Int
    gte: Int
    in: [Int!]
    lt: Int
    lte: Int
    neq: Int
    ngt: Int
    ngte: Int
    nin: [Int!]
    nlt: Int
    nlte: Int
}

input ComparableNullableOfDateTimeOperationFilterInput {
    eq: DateTime
    gt: DateTime
    gte: DateTime
    in: [DateTime]
    lt: DateTime
    lte: DateTime
    neq: DateTime
    ngt: DateTime
    ngte: DateTime
    nin: [DateTime]
    nlt: DateTime
    nlte: DateTime
}

input ComparableNullableOfInt32OperationFilterInput {
    eq: Int
    gt: Int
    gte: Int
    in: [Int]
    lt: Int
    lte: Int
    neq: Int
    ngt: Int
    ngte: Int
    nin: [Int]
    nlt: Int
    nlte: Int
}

input ComparableNullableOfSingleOperationFilterInput {
    eq: Float
    gt: Float
    gte: Float
    in: [Float]
    lt: Float
    lte: Float
    neq: Float
    ngt: Float
    ngte: Float
    nin: [Float]
    nlt: Float
    nlte: Float
}

input FeedFilterInput {
    and: [FeedFilterInput!]
    created: ComparableDateTimeOperationFilterInput
    data: StringOperationFilterInput
    id: ComparableInt32OperationFilterInput
    message: StringOperationFilterInput
    or: [FeedFilterInput!]
    tags: StringOperationFilterInput
    type: StringOperationFilterInput
}

input FeedItemCreateInput {
    data: String
    message: String
    type: String!
}

input FeedSortInput {
    created: SortEnumType
    data: SortEnumType
    id: SortEnumType
    message: SortEnumType
    tags: SortEnumType
    type: SortEnumType
}

input MaintenanceFilterInput {
    and: [MaintenanceFilterInput!]
    created: ComparableNullableOfDateTimeOperationFilterInput
    id: ComparableInt32OperationFilterInput
    name: StringOperationFilterInput
    or: [MaintenanceFilterInput!]
    price: ComparableNullableOfSingleOperationFilterInput
    property: StringOperationFilterInput
}

input MaintenanceSortInput {
    created: SortEnumType
    id: SortEnumType
    name: SortEnumType
    price: SortEnumType
    property: SortEnumType
}

input StringOperationFilterInput {
    and: [StringOperationFilterInput!]
    contains: String
    endsWith: String
    eq: String
    in: [String]
    ncontains: String
    nendsWith: String
    neq: String
    nin: [String]
    nstartsWith: String
    or: [StringOperationFilterInput!]
    startsWith: String
}
